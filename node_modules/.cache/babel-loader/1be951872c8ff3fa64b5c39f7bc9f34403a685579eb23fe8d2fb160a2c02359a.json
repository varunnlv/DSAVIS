{"ast":null,"code":"const NUM_ROWS = 30;\nconst NUM_COLS = 60;\nexport function initialGrid() {\n  const grid = [];\n  for (let row = 0; row < NUM_ROWS; row++) {\n    const currentRow = [];\n    for (let col = 0; col < NUM_COLS; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n}\nexport const createNode = (col, row, isWeightedGraph) => ({\n  col,\n  row,\n  isStart: row === 3 && col === 5,\n  isFinish: row === 26 && col === 52,\n  isVisited: false,\n  isVisualized: false,\n  isPath: false,\n  isWall: false,\n  distance: Infinity,\n  previousNode: null,\n  weight: 1\n});\nexport const toggleWall = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\nexport const findStartNode = grid => {\n  for (const row of grid) {\n    for (const node of row) {\n      if (node.isStart) return node;\n    }\n  }\n};\nexport const findFinishNode = grid => {\n  for (const row of grid) {\n    for (const node of row) {\n      if (node.isFinish) return node;\n    }\n  }\n};\n\n// Example utility function implementations\nexport const isStartNode = (grid, row, col) => {\n  // Implementation based on your grid structure\n  return grid[row][col].isStart;\n};\nexport const isFinishNode = (grid, row, col) => {\n  // Implementation based on your grid structure\n  return grid[row][col].isFinish;\n};\nexport const moveStartNode = (grid, newRow, newCol) => {\n  // Deep clone the grid to avoid direct mutations\n  const newGrid = grid.map(row => row.map(node => ({\n    ...node\n  })));\n\n  // Utilize your existing utility to find the current start node\n  const oldStartNode = findStartNode(newGrid);\n  if (oldStartNode) {\n    oldStartNode.isStart = false; // Reset the old start node\n  }\n\n  // Directly access and set the new start node\n  const newStartNode = newGrid[newRow][newCol];\n  newStartNode.isStart = true;\n  newStartNode.isWall = false; // Ensure the start node is not a wall\n\n  return newGrid;\n};\nexport const moveFinishNode = (grid, newRow, newCol) => {\n  // Deep clone the grid to avoid direct mutations\n  const newGrid = grid.map(row => row.map(node => ({\n    ...node\n  })));\n\n  // Utilize your existing utility to find the current finish node\n  const oldFinishNode = findFinishNode(newGrid);\n  if (oldFinishNode) {\n    oldFinishNode.isFinish = false; // Reset the old finish node\n  }\n\n  // Directly access and set the new finish node\n  const newFinishNode = newGrid[newRow][newCol];\n  newFinishNode.isFinish = true;\n  return newGrid;\n};","map":{"version":3,"names":["NUM_ROWS","NUM_COLS","initialGrid","grid","row","currentRow","col","push","createNode","isWeightedGraph","isStart","isFinish","isVisited","isVisualized","isPath","isWall","distance","Infinity","previousNode","weight","toggleWall","newGrid","slice","node","newNode","findStartNode","findFinishNode","isStartNode","isFinishNode","moveStartNode","newRow","newCol","map","oldStartNode","newStartNode","moveFinishNode","oldFinishNode","newFinishNode"],"sources":["D:/PR'S/pff/pathfinding-visualizer/src/utils/GridUtils.js"],"sourcesContent":["const NUM_ROWS = 30;\r\nconst NUM_COLS = 60;\r\n\r\nexport function initialGrid() {\r\n  const grid = [];\r\n  for (let row = 0; row < NUM_ROWS; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUM_COLS; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n}\r\n\r\nexport const createNode = (col, row, isWeightedGraph) => ({\r\n  col,\r\n  row,\r\n  isStart: row === 3 && col === 5,\r\n  isFinish: row === 26 && col === 52,\r\n  isVisited: false,\r\n  isVisualized: false,\r\n  isPath: false,\r\n  isWall: false,\r\n  distance: Infinity,\r\n  previousNode: null,\r\n  weight: 1,\r\n});\r\n\r\nexport const toggleWall = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = { ...node, isWall: !node.isWall };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\nexport const findStartNode = (grid) => {\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      if (node.isStart) return node;\r\n    }\r\n  }\r\n};\r\n\r\nexport const findFinishNode = (grid) => {\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      if (node.isFinish) return node;\r\n    }\r\n  }\r\n};\r\n\r\n// Example utility function implementations\r\nexport const isStartNode = (grid, row, col) => {\r\n  // Implementation based on your grid structure\r\n  return grid[row][col].isStart;\r\n};\r\n\r\nexport const isFinishNode = (grid, row, col) => {\r\n  // Implementation based on your grid structure\r\n  return grid[row][col].isFinish;\r\n};\r\n\r\nexport const moveStartNode = (grid, newRow, newCol) => {\r\n  // Deep clone the grid to avoid direct mutations\r\n  const newGrid = grid.map((row) => row.map((node) => ({ ...node })));\r\n\r\n  // Utilize your existing utility to find the current start node\r\n  const oldStartNode = findStartNode(newGrid);\r\n  if (oldStartNode) {\r\n    oldStartNode.isStart = false; // Reset the old start node\r\n  }\r\n\r\n  // Directly access and set the new start node\r\n  const newStartNode = newGrid[newRow][newCol];\r\n  newStartNode.isStart = true;\r\n  newStartNode.isWall = false; // Ensure the start node is not a wall\r\n\r\n  return newGrid;\r\n};\r\n\r\nexport const moveFinishNode = (grid, newRow, newCol) => {\r\n  // Deep clone the grid to avoid direct mutations\r\n  const newGrid = grid.map((row) => row.map((node) => ({ ...node })));\r\n\r\n  // Utilize your existing utility to find the current finish node\r\n  const oldFinishNode = findFinishNode(newGrid);\r\n  if (oldFinishNode) {\r\n    oldFinishNode.isFinish = false; // Reset the old finish node\r\n  }\r\n\r\n  // Directly access and set the new finish node\r\n  const newFinishNode = newGrid[newRow][newCol];\r\n  newFinishNode.isFinish = true;\r\n\r\n  return newGrid;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}