{"ast":null,"code":"import TinyQueue from \"tinyqueue\";\nimport { getUnvisitedNeighbors } from \"./algoHelper\";\nexport function astar(grid, startNode, finishNode) {\n  const aStarNodes = createAStarGrid(grid);\n  const visitedNodesInOrder = []; // List to store the order of visited nodes\n\n  const start = findStart(aStarNodes);\n  const finish = findFinish(aStarNodes);\n\n  // Comparator function for TinyQueue\n  const compareNodes = (a, b) => a.f - b.f;\n  const openList = new TinyQueue([], compareNodes);\n  start.isOpened = true;\n  openList.push(start);\n  while (openList.length > 0) {\n    let currentNode = openList.pop();\n    currentNode.isOpened = false;\n    visitedNodesInOrder.push(currentNode);\n    if (currentNode === finish) {\n      return visitedNodesInOrder;\n    }\n    const neighbors = getUnvisitedNeighbors(currentNode, aStarNodes);\n    for (const neighbor of neighbors) {\n      if (neighbor.isWall || neighbor.isOpened) {\n        continue;\n      }\n\n      // const gScore = currentNode.g + 1;\n      const gScore = currentNode.g + neighbor.weight;\n      if (gScore < neighbor.g) {\n        neighbor.h = heuristic(neighbor, finish);\n        neighbor.previousNode = currentNode;\n        neighbor.g = gScore;\n        neighbor.f = neighbor.g + neighbor.h;\n        if (!neighbor.isOpened) {\n          neighbor.isOpened = true;\n          openList.push(neighbor);\n        }\n      }\n    }\n  }\n  return visitedNodesInOrder;\n}\nfunction createAStarGrid(grid) {\n  const aStarGrid = grid.map((row, rowIndex) => {\n    return row.map((cell, colIndex) => {\n      return {\n        ...cell,\n        f: 0,\n        g: Infinity,\n        // Initially, all nodes have an infinite distance from the start, except the start node itself\n        h: 0,\n        previousNode: null,\n        x: rowIndex,\n        // Adding x coordinate for clarity\n        y: colIndex,\n        // Adding y coordinate for clarity\n        isOpened: false,\n        // Track whether the node is in the open list\n        weight: cell.weight || 1\n      };\n    });\n  });\n\n  // Initialize start node\n  const startNode = findStart(aStarGrid);\n  startNode.g = 0;\n  startNode.f = heuristic(startNode, findFinish(aStarGrid));\n  return aStarGrid;\n}\nfunction findStart(aStarGrid) {\n  for (const row of aStarGrid) {\n    for (const node of row) {\n      if (node.isStart) {\n        return node;\n      }\n    }\n  }\n}\nfunction findFinish(aStarGrid) {\n  for (const row of aStarGrid) {\n    for (const node of row) {\n      if (node.isFinish) {\n        return node;\n      }\n    }\n  }\n}\nfunction heuristic(pos0, pos1) {\n  return Math.abs(pos1.row - pos0.row) + Math.abs(pos1.col - pos0.col);\n}","map":{"version":3,"names":["TinyQueue","getUnvisitedNeighbors","astar","grid","startNode","finishNode","aStarNodes","createAStarGrid","visitedNodesInOrder","start","findStart","finish","findFinish","compareNodes","a","b","f","openList","isOpened","push","length","currentNode","pop","neighbors","neighbor","isWall","gScore","g","weight","h","heuristic","previousNode","aStarGrid","map","row","rowIndex","cell","colIndex","Infinity","x","y","node","isStart","isFinish","pos0","pos1","Math","abs","col"],"sources":["D:/PR'S/pff/pathfinding-visualizer/src/algorithms/astar.js"],"sourcesContent":["import TinyQueue from \"tinyqueue\";\r\nimport { getUnvisitedNeighbors } from \"./algoHelper\";\r\n\r\nexport function astar(grid, startNode, finishNode) {\r\n  const aStarNodes = createAStarGrid(grid);\r\n  const visitedNodesInOrder = []; // List to store the order of visited nodes\r\n\r\n  const start = findStart(aStarNodes);\r\n  const finish = findFinish(aStarNodes);\r\n\r\n  // Comparator function for TinyQueue\r\n  const compareNodes = (a, b) => a.f - b.f;\r\n\r\n  const openList = new TinyQueue([], compareNodes);\r\n  start.isOpened = true;\r\n  openList.push(start);\r\n\r\n  while (openList.length > 0) {\r\n    let currentNode = openList.pop();\r\n    currentNode.isOpened = false;\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    if (currentNode === finish) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    const neighbors = getUnvisitedNeighbors(currentNode, aStarNodes);\r\n    for (const neighbor of neighbors) {\r\n      if (neighbor.isWall || neighbor.isOpened) {\r\n        continue;\r\n      }\r\n\r\n      // const gScore = currentNode.g + 1;\r\n      const gScore = currentNode.g + neighbor.weight;\r\n      if (gScore < neighbor.g) {\r\n        neighbor.h = heuristic(neighbor, finish);\r\n        neighbor.previousNode = currentNode;\r\n        neighbor.g = gScore;\r\n        neighbor.f = neighbor.g + neighbor.h;\r\n        if (!neighbor.isOpened) {\r\n          neighbor.isOpened = true;\r\n          openList.push(neighbor);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction createAStarGrid(grid) {\r\n  const aStarGrid = grid.map((row, rowIndex) => {\r\n    return row.map((cell, colIndex) => {\r\n      return {\r\n        ...cell,\r\n        f: 0,\r\n        g: Infinity, // Initially, all nodes have an infinite distance from the start, except the start node itself\r\n        h: 0,\r\n        previousNode: null,\r\n        x: rowIndex, // Adding x coordinate for clarity\r\n        y: colIndex, // Adding y coordinate for clarity\r\n        isOpened: false, // Track whether the node is in the open list\r\n        weight: cell.weight || 1,\r\n      };\r\n    });\r\n  });\r\n\r\n  // Initialize start node\r\n  const startNode = findStart(aStarGrid);\r\n  startNode.g = 0;\r\n  startNode.f = heuristic(startNode, findFinish(aStarGrid));\r\n\r\n  return aStarGrid;\r\n}\r\n\r\nfunction findStart(aStarGrid) {\r\n  for (const row of aStarGrid) {\r\n    for (const node of row) {\r\n      if (node.isStart) {\r\n        return node;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction findFinish(aStarGrid) {\r\n  for (const row of aStarGrid) {\r\n    for (const node of row) {\r\n      if (node.isFinish) {\r\n        return node;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction heuristic(pos0, pos1) {\r\n  return Math.abs(pos1.row - pos0.row) + Math.abs(pos1.col - pos0.col);\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}