{"ast":null,"code":"var _s = $RefreshSig$();\n// useVisualization.js\nimport { useRef, useCallback } from \"react\";\nimport { initialGrid } from \"../utils/GridUtils\";\nexport const useVisualization = (grid, setGrid) => {\n  _s();\n  const timeoutIdsRef = useRef([]);\n\n  // Function to clear all timeouts\n  const clearAllTimeouts = useCallback(() => {\n    timeoutIdsRef.current.forEach(clearTimeout);\n    timeoutIdsRef.current = [];\n  }, []);\n\n  // Function to clear the board\n  const clearBoard = useCallback(() => {\n    clearAllTimeouts();\n    setGrid(initialGrid());\n  }, [initialGrid, clearAllTimeouts]);\n  const clearWeights = useCallback(() => {\n    clearAllTimeouts();\n    setGrid(prevGrid => prevGrid.map(row => row.map(node => ({\n      ...node,\n      // isPath: false,\n      // distance: Infinity,\n      // isVisualized: false,\n      // isVisited: false,\n      // previousNode: null,\n      weight: 1\n    }))));\n  }, [clearAllTimeouts, setGrid]);\n  const clearWalls = useCallback(() => {\n    clearAllTimeouts();\n    setGrid(prevGrid => prevGrid.map(row => row.map(node => ({\n      ...node,\n      // isPath: false,\n      // distance: Infinity,\n      // isVisualized: false,\n      // isVisited: false,\n      // previousNode: null,\n      // weight: 1,\n      isWall: false\n    }))));\n  }, [clearAllTimeouts, setGrid]);\n  const resetForVisualization = useCallback(() => {\n    clearAllTimeouts();\n    setGrid(prevGrid => {\n      return prevGrid.map(row => row.map(node => ({\n        ...node,\n        isVisualized: false,\n        isPath: false,\n        isVisited: false,\n        distance: Infinity,\n        previousNode: null\n      })));\n    });\n  }, [clearAllTimeouts, setGrid]);\n  const resetForMaze = useCallback(() => {\n    clearAllTimeouts();\n    setGrid(prevGrid => {\n      return prevGrid.map(row => row.map(node => ({\n        ...node,\n        isVisualized: false,\n        isPath: false,\n        isVisited: false,\n        distance: Infinity,\n        previousNode: null,\n        isWall: false,\n        weight: 1\n      })));\n    });\n  }, [clearAllTimeouts, setGrid]);\n\n  // Function to animate Dijkstra's algorithm\n  const visualize = useCallback((visitedNodesInOrder, nodesInShortestPathOrder) => {\n    clearAllTimeouts();\n    visitedNodesInOrder.forEach((node, index) => {\n      const timeoutId = setTimeout(() => {\n        setGrid(prevGrid => {\n          const newGrid = prevGrid.map((row, rowIndex) => row.map((n, colIndex) => {\n            if (n.row === node.row && n.col === node.col) {\n              return {\n                ...n,\n                isVisualized: true,\n                distance: node.distance\n              };\n            }\n            return n;\n          }));\n          return newGrid;\n        });\n      }, 10 * index);\n      timeoutIdsRef.current.push(timeoutId);\n    });\n\n    // Animate shortest path\n    const totalAnimationTime = visitedNodesInOrder.length * 10;\n    nodesInShortestPathOrder.forEach((node, index) => {\n      const timeoutId = setTimeout(() => {\n        setGrid(prevGrid => {\n          const newGrid = prevGrid.map(row => row.map(n => {\n            if (n.row === node.row && n.col === node.col) {\n              // Adjusted condition\n              return {\n                ...n,\n                isPath: true,\n                distance: node.distance\n              };\n            }\n            return n;\n          }));\n          return newGrid;\n        });\n      }, totalAnimationTime + 50 * index);\n      timeoutIdsRef.current.push(timeoutId);\n    });\n  }, [setGrid, clearAllTimeouts]);\n  return {\n    visualize,\n    clearBoard,\n    clearWeights,\n    clearWalls,\n    resetForVisualization,\n    resetForMaze\n  };\n};\n_s(useVisualization, \"lDEvmEV6FqoShEDfMpmfKNyniv4=\");","map":{"version":3,"names":["useRef","useCallback","initialGrid","useVisualization","grid","setGrid","_s","timeoutIdsRef","clearAllTimeouts","current","forEach","clearTimeout","clearBoard","clearWeights","prevGrid","map","row","node","weight","clearWalls","isWall","resetForVisualization","isVisualized","isPath","isVisited","distance","Infinity","previousNode","resetForMaze","visualize","visitedNodesInOrder","nodesInShortestPathOrder","index","timeoutId","setTimeout","newGrid","rowIndex","n","colIndex","col","push","totalAnimationTime","length"],"sources":["D:/PR'S/pff/pathfinding-visualizer/src/hooks/useVisualization.jsx"],"sourcesContent":["// useVisualization.js\r\nimport { useRef, useCallback } from \"react\";\r\nimport { initialGrid } from \"../utils/GridUtils\";\r\n\r\nexport const useVisualization = (grid, setGrid) => {\r\n  const timeoutIdsRef = useRef([]);\r\n\r\n  // Function to clear all timeouts\r\n  const clearAllTimeouts = useCallback(() => {\r\n    timeoutIdsRef.current.forEach(clearTimeout);\r\n    timeoutIdsRef.current = [];\r\n  }, []);\r\n\r\n  // Function to clear the board\r\n  const clearBoard = useCallback(() => {\r\n    clearAllTimeouts();\r\n    setGrid(initialGrid());\r\n  }, [initialGrid, clearAllTimeouts]);\r\n\r\n  const clearWeights = useCallback(() => {\r\n    clearAllTimeouts();\r\n    setGrid((prevGrid) =>\r\n      prevGrid.map((row) =>\r\n        row.map((node) => ({\r\n          ...node,\r\n          // isPath: false,\r\n          // distance: Infinity,\r\n          // isVisualized: false,\r\n          // isVisited: false,\r\n          // previousNode: null,\r\n          weight: 1,\r\n        }))\r\n      )\r\n    );\r\n  }, [clearAllTimeouts, setGrid]);\r\n\r\n  const clearWalls = useCallback(() => {\r\n    clearAllTimeouts();\r\n    setGrid((prevGrid) =>\r\n      prevGrid.map((row) =>\r\n        row.map((node) => ({\r\n          ...node,\r\n          // isPath: false,\r\n          // distance: Infinity,\r\n          // isVisualized: false,\r\n          // isVisited: false,\r\n          // previousNode: null,\r\n          // weight: 1,\r\n          isWall: false,\r\n        }))\r\n      )\r\n    );\r\n  }, [clearAllTimeouts, setGrid]);\r\n\r\n  const resetForVisualization = useCallback(() => {\r\n    clearAllTimeouts();\r\n    setGrid((prevGrid) => {\r\n      return prevGrid.map((row) =>\r\n        row.map((node) => ({\r\n          ...node,\r\n          isVisualized: false,\r\n          isPath: false,\r\n          isVisited: false,\r\n          distance: Infinity,\r\n          previousNode: null,\r\n        }))\r\n      );\r\n    });\r\n  }, [clearAllTimeouts, setGrid]);\r\n\r\n  const resetForMaze = useCallback(() => {\r\n    clearAllTimeouts();\r\n    setGrid((prevGrid) => {\r\n      return prevGrid.map((row) =>\r\n        row.map((node) => ({\r\n          ...node,\r\n          isVisualized: false,\r\n          isPath: false,\r\n          isVisited: false,\r\n          distance: Infinity,\r\n          previousNode: null,\r\n          isWall: false,\r\n          weight: 1,\r\n        }))\r\n      );\r\n    });\r\n  }, [clearAllTimeouts, setGrid]);\r\n\r\n  // Function to animate Dijkstra's algorithm\r\n  const visualize = useCallback(\r\n    (visitedNodesInOrder, nodesInShortestPathOrder) => {\r\n      clearAllTimeouts();\r\n      visitedNodesInOrder.forEach((node, index) => {\r\n        const timeoutId = setTimeout(() => {\r\n          setGrid((prevGrid) => {\r\n            const newGrid = prevGrid.map((row, rowIndex) =>\r\n              row.map((n, colIndex) => {\r\n                if (n.row === node.row && n.col === node.col) {\r\n                  return { ...n, isVisualized: true, distance: node.distance };\r\n                }\r\n                return n;\r\n              })\r\n            );\r\n            return newGrid;\r\n          });\r\n        }, 10 * index);\r\n        timeoutIdsRef.current.push(timeoutId);\r\n      });\r\n\r\n      // Animate shortest path\r\n      const totalAnimationTime = visitedNodesInOrder.length * 10;\r\n      nodesInShortestPathOrder.forEach((node, index) => {\r\n        const timeoutId = setTimeout(() => {\r\n          setGrid((prevGrid) => {\r\n            const newGrid = prevGrid.map((row) =>\r\n              row.map((n) => {\r\n                if (n.row === node.row && n.col === node.col) {\r\n                  // Adjusted condition\r\n                  return { ...n, isPath: true, distance: node.distance };\r\n                }\r\n                return n;\r\n              })\r\n            );\r\n            return newGrid;\r\n          });\r\n        }, totalAnimationTime + 50 * index);\r\n        timeoutIdsRef.current.push(timeoutId);\r\n      });\r\n    },\r\n    [setGrid, clearAllTimeouts]\r\n  );\r\n\r\n  return {\r\n    visualize,\r\n    clearBoard,\r\n    clearWeights,\r\n    clearWalls,\r\n    resetForVisualization,\r\n    resetForMaze,\r\n  };\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}