{"ast":null,"code":"import TinyQueue from \"tinyqueue\";\nimport { getUnvisitedNeighbors } from \"./algoHelper\";\nexport function gbfs(grid, startNode, finishNode) {\n  console.log(\"gbfs\");\n  const gbfsNodes = createGbfsGrid(grid);\n  const visitedNodesInOrder = [];\n  const start = findStart(gbfsNodes);\n  const finish = findFinish(gbfsNodes);\n  const compareNodes = (a, b) => a.h - b.h;\n  const openList = new TinyQueue([], compareNodes);\n  start.isOpened = true;\n  openList.push(start);\n  while (openList.length > 0) {\n    let currentNode = openList.pop();\n    currentNode.isOpened = false;\n    currentNode.visited = true;\n    visitedNodesInOrder.push(currentNode);\n    if (currentNode === finish) {\n      return visitedNodesInOrder;\n    }\n    const neighbors = getUnvisitedNeighbors(currentNode, gbfsNodes);\n    for (const neighbor of neighbors) {\n      if (neighbor.isWall || neighbor.visited) {\n        // Check if neighbor is visited\n        continue;\n      }\n      neighbor.h = heuristic(neighbor, finish);\n      neighbor.previousNode = currentNode;\n      neighbor.visited = true;\n      if (!neighbor.isOpened) {\n        neighbor.isOpened = true;\n        openList.push(neighbor);\n      }\n    }\n  }\n  return visitedNodesInOrder;\n}\nfunction createGbfsGrid(grid) {\n  return grid.map((row, rowIndex) => {\n    return row.map((cell, colIndex) => {\n      return {\n        ...cell,\n        h: Infinity,\n        previousNode: null,\n        x: rowIndex,\n        y: colIndex,\n        isOpened: false\n      };\n    });\n  });\n}\nfunction findStart(gbfsGrid) {\n  for (const row of gbfsGrid) {\n    for (const node of row) {\n      if (node.isStart) {\n        return node;\n      }\n    }\n  }\n}\nfunction findFinish(gbfsGrid) {\n  for (const row of gbfsGrid) {\n    for (const node of row) {\n      if (node.isFinish) {\n        return node;\n      }\n    }\n  }\n}\nfunction heuristic(pos0, pos1) {\n  return Math.abs(pos1.row - pos0.row) + Math.abs(pos1.col - pos0.col);\n}","map":{"version":3,"names":["TinyQueue","getUnvisitedNeighbors","gbfs","grid","startNode","finishNode","console","log","gbfsNodes","createGbfsGrid","visitedNodesInOrder","start","findStart","finish","findFinish","compareNodes","a","b","h","openList","isOpened","push","length","currentNode","pop","visited","neighbors","neighbor","isWall","heuristic","previousNode","map","row","rowIndex","cell","colIndex","Infinity","x","y","gbfsGrid","node","isStart","isFinish","pos0","pos1","Math","abs","col"],"sources":["D:/PR'S/pff/pathfinding-visualizer/src/algorithms/gbfs.js"],"sourcesContent":["import TinyQueue from \"tinyqueue\";\r\nimport { getUnvisitedNeighbors } from \"./algoHelper\";\r\n\r\nexport function gbfs(grid, startNode, finishNode) {\r\n  console.log(\"gbfs\");\r\n  const gbfsNodes = createGbfsGrid(grid);\r\n  const visitedNodesInOrder = [];\r\n\r\n  const start = findStart(gbfsNodes);\r\n  const finish = findFinish(gbfsNodes);\r\n\r\n  const compareNodes = (a, b) => a.h - b.h;\r\n\r\n  const openList = new TinyQueue([], compareNodes);\r\n  start.isOpened = true;\r\n  openList.push(start);\r\n\r\n  while (openList.length > 0) {\r\n    let currentNode = openList.pop();\r\n    currentNode.isOpened = false;\r\n    currentNode.visited = true;\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    if (currentNode === finish) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    const neighbors = getUnvisitedNeighbors(currentNode, gbfsNodes);\r\n    for (const neighbor of neighbors) {\r\n      if (neighbor.isWall || neighbor.visited) {\r\n        // Check if neighbor is visited\r\n        continue;\r\n      }\r\n\r\n      neighbor.h = heuristic(neighbor, finish);\r\n      neighbor.previousNode = currentNode;\r\n      neighbor.visited = true;\r\n\r\n      if (!neighbor.isOpened) {\r\n        neighbor.isOpened = true;\r\n        openList.push(neighbor);\r\n      }\r\n    }\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction createGbfsGrid(grid) {\r\n  return grid.map((row, rowIndex) => {\r\n    return row.map((cell, colIndex) => {\r\n      return {\r\n        ...cell,\r\n        h: Infinity,\r\n        previousNode: null,\r\n        x: rowIndex,\r\n        y: colIndex,\r\n        isOpened: false,\r\n      };\r\n    });\r\n  });\r\n}\r\n\r\nfunction findStart(gbfsGrid) {\r\n  for (const row of gbfsGrid) {\r\n    for (const node of row) {\r\n      if (node.isStart) {\r\n        return node;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction findFinish(gbfsGrid) {\r\n  for (const row of gbfsGrid) {\r\n    for (const node of row) {\r\n      if (node.isFinish) {\r\n        return node;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction heuristic(pos0, pos1) {\r\n  return Math.abs(pos1.row - pos0.row) + Math.abs(pos1.col - pos0.col);\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}