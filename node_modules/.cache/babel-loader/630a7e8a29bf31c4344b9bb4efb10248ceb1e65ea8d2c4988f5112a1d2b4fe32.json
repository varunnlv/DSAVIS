{"ast":null,"code":"import { getUnvisitedNeighbors } from \"./algoHelper\";\nexport function bidirectional(grid, startNode, finishNode) {\n  let visitedNodesInOrder = [];\n  startNode.distanceFromStart = 0;\n  finishNode.distanceFromFinish = 0;\n  let queueFromStart = [startNode];\n  let queueFromFinish = [finishNode];\n  let visitedFromStart = new Set([startNode]);\n  let visitedFromFinish = new Set([finishNode]);\n  while (queueFromStart.length > 0 && queueFromFinish.length > 0) {\n    let meetingNode = expandSearchFromStart() || expandSearchFromFinish();\n    if (meetingNode) {\n      linkPath(meetingNode);\n      break;\n    }\n  }\n  return visitedNodesInOrder;\n  function expandSearchFromStart() {\n    if (queueFromStart.length === 0) return null;\n    let currentNode = queueFromStart.shift();\n    visitedNodesInOrder.push(currentNode);\n    if (visitedFromFinish.has(currentNode)) return currentNode;\n    processNeighbors(currentNode, queueFromStart, visitedFromStart, \"visitedFromStart\", \"previousNode\");\n    return null;\n  }\n  function expandSearchFromFinish() {\n    if (queueFromFinish.length === 0) return null;\n    let currentNode = queueFromFinish.shift();\n    visitedNodesInOrder.push(currentNode);\n    if (visitedFromStart.has(currentNode)) return currentNode;\n    processNeighbors(currentNode, queueFromFinish, visitedFromFinish, \"visitedFromFinish\", \"previousNodeFromFinish\");\n    return null;\n  }\n  function processNeighbors(node, queue, visitedSet, visitedProp, previousNodeProp) {\n    let neighbors = getUnvisitedNeighbors(node, grid);\n    for (let neighbor of neighbors) {\n      if (!neighbor.isWall && !visitedSet.has(neighbor)) {\n        neighbor[visitedProp] = true;\n        neighbor[previousNodeProp] = node;\n        visitedSet.add(neighbor);\n        queue.push(neighbor);\n      }\n    }\n  }\n  function linkPath(meetingNode) {\n    let cur = meetingNode;\n    while (!cur.isFinish) {\n      cur.previousNodeFromFinish.previousNode = cur;\n      cur = cur.previousNodeFromFinish;\n    }\n  }\n}","map":{"version":3,"names":["getUnvisitedNeighbors","bidirectional","grid","startNode","finishNode","visitedNodesInOrder","distanceFromStart","distanceFromFinish","queueFromStart","queueFromFinish","visitedFromStart","Set","visitedFromFinish","length","meetingNode","expandSearchFromStart","expandSearchFromFinish","linkPath","currentNode","shift","push","has","processNeighbors","node","queue","visitedSet","visitedProp","previousNodeProp","neighbors","neighbor","isWall","add","cur","isFinish","previousNodeFromFinish","previousNode"],"sources":["D:/PR'S/pff/pathfinding-visualizer/src/algorithms/bidirectional.js"],"sourcesContent":["import { getUnvisitedNeighbors } from \"./algoHelper\";\r\n\r\nexport function bidirectional(grid, startNode, finishNode) {\r\n  let visitedNodesInOrder = [];\r\n  startNode.distanceFromStart = 0;\r\n  finishNode.distanceFromFinish = 0;\r\n\r\n  let queueFromStart = [startNode];\r\n  let queueFromFinish = [finishNode];\r\n\r\n  let visitedFromStart = new Set([startNode]);\r\n  let visitedFromFinish = new Set([finishNode]);\r\n\r\n  while (queueFromStart.length > 0 && queueFromFinish.length > 0) {\r\n    let meetingNode = expandSearchFromStart() || expandSearchFromFinish();\r\n    if (meetingNode) {\r\n      linkPath(meetingNode);\r\n      break;\r\n    }\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n\r\n  function expandSearchFromStart() {\r\n    if (queueFromStart.length === 0) return null;\r\n    let currentNode = queueFromStart.shift();\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    if (visitedFromFinish.has(currentNode)) return currentNode;\r\n\r\n    processNeighbors(\r\n      currentNode,\r\n      queueFromStart,\r\n      visitedFromStart,\r\n      \"visitedFromStart\",\r\n      \"previousNode\"\r\n    );\r\n    return null;\r\n  }\r\n\r\n  function expandSearchFromFinish() {\r\n    if (queueFromFinish.length === 0) return null;\r\n    let currentNode = queueFromFinish.shift();\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    if (visitedFromStart.has(currentNode)) return currentNode;\r\n\r\n    processNeighbors(\r\n      currentNode,\r\n      queueFromFinish,\r\n      visitedFromFinish,\r\n      \"visitedFromFinish\",\r\n      \"previousNodeFromFinish\"\r\n    );\r\n    return null;\r\n  }\r\n\r\n  function processNeighbors(\r\n    node,\r\n    queue,\r\n    visitedSet,\r\n    visitedProp,\r\n    previousNodeProp\r\n  ) {\r\n    let neighbors = getUnvisitedNeighbors(node, grid);\r\n    for (let neighbor of neighbors) {\r\n      if (!neighbor.isWall && !visitedSet.has(neighbor)) {\r\n        neighbor[visitedProp] = true;\r\n        neighbor[previousNodeProp] = node;\r\n        visitedSet.add(neighbor);\r\n        queue.push(neighbor);\r\n      }\r\n    }\r\n  }\r\n\r\n  function linkPath(meetingNode) {\r\n    let cur = meetingNode;\r\n\r\n    while (!cur.isFinish) {\r\n      cur.previousNodeFromFinish.previousNode = cur;\r\n      cur = cur.previousNodeFromFinish;\r\n    }\r\n  }\r\n}\r\n"],"mappings":"AAAA,SAASA,qBAAqB,QAAQ,cAAc;AAEpD,OAAO,SAASC,aAAaA,CAACC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAE;EACzD,IAAIC,mBAAmB,GAAG,EAAE;EAC5BF,SAAS,CAACG,iBAAiB,GAAG,CAAC;EAC/BF,UAAU,CAACG,kBAAkB,GAAG,CAAC;EAEjC,IAAIC,cAAc,GAAG,CAACL,SAAS,CAAC;EAChC,IAAIM,eAAe,GAAG,CAACL,UAAU,CAAC;EAElC,IAAIM,gBAAgB,GAAG,IAAIC,GAAG,CAAC,CAACR,SAAS,CAAC,CAAC;EAC3C,IAAIS,iBAAiB,GAAG,IAAID,GAAG,CAAC,CAACP,UAAU,CAAC,CAAC;EAE7C,OAAOI,cAAc,CAACK,MAAM,GAAG,CAAC,IAAIJ,eAAe,CAACI,MAAM,GAAG,CAAC,EAAE;IAC9D,IAAIC,WAAW,GAAGC,qBAAqB,CAAC,CAAC,IAAIC,sBAAsB,CAAC,CAAC;IACrE,IAAIF,WAAW,EAAE;MACfG,QAAQ,CAACH,WAAW,CAAC;MACrB;IACF;EACF;EAEA,OAAOT,mBAAmB;EAE1B,SAASU,qBAAqBA,CAAA,EAAG;IAC/B,IAAIP,cAAc,CAACK,MAAM,KAAK,CAAC,EAAE,OAAO,IAAI;IAC5C,IAAIK,WAAW,GAAGV,cAAc,CAACW,KAAK,CAAC,CAAC;IACxCd,mBAAmB,CAACe,IAAI,CAACF,WAAW,CAAC;IAErC,IAAIN,iBAAiB,CAACS,GAAG,CAACH,WAAW,CAAC,EAAE,OAAOA,WAAW;IAE1DI,gBAAgB,CACdJ,WAAW,EACXV,cAAc,EACdE,gBAAgB,EAChB,kBAAkB,EAClB,cACF,CAAC;IACD,OAAO,IAAI;EACb;EAEA,SAASM,sBAAsBA,CAAA,EAAG;IAChC,IAAIP,eAAe,CAACI,MAAM,KAAK,CAAC,EAAE,OAAO,IAAI;IAC7C,IAAIK,WAAW,GAAGT,eAAe,CAACU,KAAK,CAAC,CAAC;IACzCd,mBAAmB,CAACe,IAAI,CAACF,WAAW,CAAC;IAErC,IAAIR,gBAAgB,CAACW,GAAG,CAACH,WAAW,CAAC,EAAE,OAAOA,WAAW;IAEzDI,gBAAgB,CACdJ,WAAW,EACXT,eAAe,EACfG,iBAAiB,EACjB,mBAAmB,EACnB,wBACF,CAAC;IACD,OAAO,IAAI;EACb;EAEA,SAASU,gBAAgBA,CACvBC,IAAI,EACJC,KAAK,EACLC,UAAU,EACVC,WAAW,EACXC,gBAAgB,EAChB;IACA,IAAIC,SAAS,GAAG5B,qBAAqB,CAACuB,IAAI,EAAErB,IAAI,CAAC;IACjD,KAAK,IAAI2B,QAAQ,IAAID,SAAS,EAAE;MAC9B,IAAI,CAACC,QAAQ,CAACC,MAAM,IAAI,CAACL,UAAU,CAACJ,GAAG,CAACQ,QAAQ,CAAC,EAAE;QACjDA,QAAQ,CAACH,WAAW,CAAC,GAAG,IAAI;QAC5BG,QAAQ,CAACF,gBAAgB,CAAC,GAAGJ,IAAI;QACjCE,UAAU,CAACM,GAAG,CAACF,QAAQ,CAAC;QACxBL,KAAK,CAACJ,IAAI,CAACS,QAAQ,CAAC;MACtB;IACF;EACF;EAEA,SAASZ,QAAQA,CAACH,WAAW,EAAE;IAC7B,IAAIkB,GAAG,GAAGlB,WAAW;IAErB,OAAO,CAACkB,GAAG,CAACC,QAAQ,EAAE;MACpBD,GAAG,CAACE,sBAAsB,CAACC,YAAY,GAAGH,GAAG;MAC7CA,GAAG,GAAGA,GAAG,CAACE,sBAAsB;IAClC;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}