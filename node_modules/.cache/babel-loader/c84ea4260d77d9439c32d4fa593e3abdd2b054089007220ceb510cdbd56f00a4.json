{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback } from \"react\";\nimport { initialGrid, toggleWall, isStartNode, isFinishNode, moveStartNode, moveFinishNode } from \"../utils/GridUtils\";\nexport const useGridHandler = (grid, setGrid) => {\n  _s();\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const [actionType, setActionType] = useState(null);\n  const handleMouseDown = useCallback((event, row, col) => {\n    setMouseIsPressed(true);\n    if (event.shiftKey) {\n      // If Shift is pressed, set the weight of the node to 30\n      setActionType(\"setWeight\");\n      const newGrid = grid.map((gridRow, gridRowIndex) => gridRow.map((node, nodeColIndex) => {\n        if (gridRowIndex === row && nodeColIndex === col) {\n          const newWeight = node.weight === 30 ? 1 : 30; // Toggle weight between 30 and 1\n          return {\n            ...node,\n            weight: newWeight\n          };\n        }\n        return node;\n      }));\n      setGrid(newGrid);\n    } else if (isStartNode(grid, row, col) || isFinishNode(grid, row, col)) {\n      setActionType(isStartNode(grid, row, col) ? \"moveStart\" : \"moveFinish\");\n    } else {\n      setActionType(\"toggleWall\");\n      const newGrid = toggleWall(grid, row, col);\n      setGrid(newGrid);\n    }\n  }, [grid, setGrid]);\n  const handleMouseEnter = useCallback((row, col) => {\n    if (!mouseIsPressed) return;\n    let newGrid;\n    switch (actionType) {\n      case \"setWeight\":\n        newGrid = grid.map((gridRow, gridRowIndex) => gridRow.map((node, nodeColIndex) => {\n          if (gridRowIndex === row && nodeColIndex === col) {\n            const newWeight = node.weight === 30 ? 1 : 30; // Toggle weight between 30 and 1 for drag over\n            return {\n              ...node,\n              weight: newWeight\n            };\n          }\n          return node;\n        }));\n        break;\n      case \"moveStart\":\n      case \"moveFinish\":\n        newGrid = actionType === \"moveStart\" ? moveStartNode(grid, row, col) : moveFinishNode(grid, row, col);\n        break;\n      case \"toggleWall\":\n      default:\n        newGrid = toggleWall(grid, row, col);\n    }\n    setGrid(newGrid);\n  }, [grid, setGrid, mouseIsPressed, actionType]);\n  const handleMouseUp = useCallback(() => {\n    setMouseIsPressed(false);\n    setActionType(null); // Reset action type\n  }, []);\n  return {\n    handleMouseDown,\n    handleMouseEnter,\n    handleMouseUp\n  };\n};\n_s(useGridHandler, \"ulmBzVNHvUXXsTiPizodDnVITSE=\");","map":{"version":3,"names":["useState","useCallback","initialGrid","toggleWall","isStartNode","isFinishNode","moveStartNode","moveFinishNode","useGridHandler","grid","setGrid","_s","mouseIsPressed","setMouseIsPressed","actionType","setActionType","handleMouseDown","event","row","col","shiftKey","newGrid","map","gridRow","gridRowIndex","node","nodeColIndex","newWeight","weight","handleMouseEnter","handleMouseUp"],"sources":["D:/PR'S/pff/pathfinding-visualizer/src/hooks/useGridHandler.jsx"],"sourcesContent":["import { useState, useCallback } from \"react\";\r\n\r\nimport {\r\n  initialGrid,\r\n  toggleWall,\r\n  isStartNode,\r\n  isFinishNode,\r\n  moveStartNode,\r\n  moveFinishNode,\r\n} from \"../utils/GridUtils\";\r\n\r\nexport const useGridHandler = (grid, setGrid) => {\r\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\r\n  const [actionType, setActionType] = useState(null);\r\n\r\n  const handleMouseDown = useCallback(\r\n    (event, row, col) => {\r\n      setMouseIsPressed(true);\r\n      if (event.shiftKey) {\r\n        // If Shift is pressed, set the weight of the node to 30\r\n        setActionType(\"setWeight\");\r\n        const newGrid = grid.map((gridRow, gridRowIndex) =>\r\n          gridRow.map((node, nodeColIndex) => {\r\n            if (gridRowIndex === row && nodeColIndex === col) {\r\n              const newWeight = node.weight === 30 ? 1 : 30; // Toggle weight between 30 and 1\r\n              return { ...node, weight: newWeight };\r\n            }\r\n            return node;\r\n          })\r\n        );\r\n        setGrid(newGrid);\r\n      } else if (isStartNode(grid, row, col) || isFinishNode(grid, row, col)) {\r\n        setActionType(isStartNode(grid, row, col) ? \"moveStart\" : \"moveFinish\");\r\n      } else {\r\n        setActionType(\"toggleWall\");\r\n        const newGrid = toggleWall(grid, row, col);\r\n        setGrid(newGrid);\r\n      }\r\n    },\r\n    [grid, setGrid]\r\n  );\r\n\r\n  const handleMouseEnter = useCallback(\r\n    (row, col) => {\r\n      if (!mouseIsPressed) return;\r\n      let newGrid;\r\n      switch (actionType) {\r\n        case \"setWeight\":\r\n          newGrid = grid.map((gridRow, gridRowIndex) =>\r\n            gridRow.map((node, nodeColIndex) => {\r\n              if (gridRowIndex === row && nodeColIndex === col) {\r\n                const newWeight = node.weight === 30 ? 1 : 30; // Toggle weight between 30 and 1 for drag over\r\n                return { ...node, weight: newWeight };\r\n              }\r\n              return node;\r\n            })\r\n          );\r\n          break;\r\n        case \"moveStart\":\r\n        case \"moveFinish\":\r\n          newGrid =\r\n            actionType === \"moveStart\"\r\n              ? moveStartNode(grid, row, col)\r\n              : moveFinishNode(grid, row, col);\r\n          break;\r\n        case \"toggleWall\":\r\n        default:\r\n          newGrid = toggleWall(grid, row, col);\r\n      }\r\n      setGrid(newGrid);\r\n    },\r\n    [grid, setGrid, mouseIsPressed, actionType]\r\n  );\r\n\r\n  const handleMouseUp = useCallback(() => {\r\n    setMouseIsPressed(false);\r\n    setActionType(null); // Reset action type\r\n  }, []);\r\n\r\n  return { handleMouseDown, handleMouseEnter, handleMouseUp };\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}