{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useCallback } from \"react\";\nexport const useMazeGenerator = (grid, setGrid) => {\n  _s();\n  const randomizeBoard = useCallback(() => {\n    setGrid(grid => grid.map(row => row.map(node => {\n      if (node.isStart || node.isFinish) {\n        return node;\n      }\n      const isWall = Math.random() < 0.3;\n      return {\n        ...node,\n        isWall\n      };\n    })));\n  }, [setGrid]);\n  const generateWeightedMaze = useCallback(() => {\n    setGrid(prevGrid => {\n      return prevGrid.map(row => row.map(node => {\n        // Avoid altering the start, finish, or wall nodes\n        if (node.isStart || node.isFinish || node.isWall) return node;\n\n        // Randomly decide to assign a high weight to some nodes\n        const assignHighWeight = Math.random() < 0.2; // 20% chance for simplicity\n        if (assignHighWeight) {\n          return {\n            ...node,\n            weight: Math.floor(Math.random() * 20) + 20\n          }; // Weights between 10 and 29\n        }\n        return node;\n      }));\n    });\n  }, [setGrid]);\n  const generateRecursiveDivisionMaze = useCallback(() => {\n    setGrid(prevGrid => {\n      // Initialize the grid, preserving the start and finish nodes\n      const gridCopy = prevGrid.map((row, rowIndex) => row.map((node, colIndex) => ({\n        ...node,\n        isWall: (rowIndex === 0 || rowIndex === prevGrid.length - 1 || colIndex === 0 || colIndex === row.length - 1) && !node.isStart && !node.isFinish\n      })));\n      divideGrid(gridCopy, 1, gridCopy.length - 2, 1, gridCopy[0].length - 2, chooseOrientation(gridCopy.length - 2, gridCopy[0].length - 2));\n      return gridCopy;\n    });\n  }, [setGrid]);\n  const chooseOrientation = (height, width) => {\n    if (width < height) {\n      return \"HORIZONTAL\";\n    } else if (height < width) {\n      return \"VERTICAL\";\n    } else {\n      return Math.random() >= 0.5 ? \"HORIZONTAL\" : \"VERTICAL\";\n    }\n  };\n  const divideGrid = useCallback((grid, rowStart, rowEnd, colStart, colEnd, orientation) => {\n    if (rowEnd - rowStart < 2 || colEnd - colStart < 2) {\n      return; // Not enough space to divide further\n    }\n    const isHorizontal = orientation === \"HORIZONTAL\";\n    if (isHorizontal) {\n      const wallRow = Math.floor(Math.random() * ((rowEnd - rowStart) / 2)) * 2 + rowStart + 1;\n      const passageCol = Math.floor(Math.random() * ((colEnd - colStart + 1) / 2)) * 2 + colStart;\n      for (let col = colStart; col <= colEnd; col++) {\n        if (col === passageCol || grid[wallRow][col].isStart || grid[wallRow][col].isFinish) continue;\n        grid[wallRow][col].isWall = true;\n      }\n      divideGrid(grid, rowStart, wallRow - 1, colStart, colEnd, chooseOrientation(wallRow - rowStart, colEnd - colStart + 1));\n      divideGrid(grid, wallRow + 1, rowEnd, colStart, colEnd, chooseOrientation(rowEnd - wallRow, colEnd - colStart + 1));\n    } else {\n      const wallCol = Math.floor(Math.random() * ((colEnd - colStart) / 2)) * 2 + colStart + 1;\n      const passageRow = Math.floor(Math.random() * ((rowEnd - rowStart + 1) / 2)) * 2 + rowStart;\n      for (let row = rowStart; row <= rowEnd; row++) {\n        if (row === passageRow || grid[row][wallCol].isStart || grid[row][wallCol].isFinish) continue;\n        grid[row][wallCol].isWall = true;\n      }\n      divideGrid(grid, rowStart, rowEnd, colStart, wallCol - 1, chooseOrientation(rowEnd - rowStart + 1, wallCol - colStart));\n      divideGrid(grid, rowStart, rowEnd, wallCol + 1, colEnd, chooseOrientation(rowEnd - rowStart + 1, colEnd - wallCol));\n    }\n  }, []);\n  return {\n    randomizeBoard,\n    generateWeightedMaze,\n    generateRecursiveDivisionMaze\n  };\n};\n_s(useMazeGenerator, \"WQxMeXB6CpNAQL2boFQMpFf0KGc=\");","map":{"version":3,"names":["useCallback","useMazeGenerator","grid","setGrid","_s","randomizeBoard","map","row","node","isStart","isFinish","isWall","Math","random","generateWeightedMaze","prevGrid","assignHighWeight","weight","floor","generateRecursiveDivisionMaze","gridCopy","rowIndex","colIndex","length","divideGrid","chooseOrientation","height","width","rowStart","rowEnd","colStart","colEnd","orientation","isHorizontal","wallRow","passageCol","col","wallCol","passageRow"],"sources":["D:/PR'S/pff/pathfinding-visualizer/src/hooks/useMazeGenerator.jsx"],"sourcesContent":["import { useCallback } from \"react\";\r\n\r\nexport const useMazeGenerator = (grid, setGrid) => {\r\n  const randomizeBoard = useCallback(() => {\r\n    setGrid((grid) =>\r\n      grid.map((row) =>\r\n        row.map((node) => {\r\n          if (node.isStart || node.isFinish) {\r\n            return node;\r\n          }\r\n          const isWall = Math.random() < 0.3;\r\n          return { ...node, isWall };\r\n        })\r\n      )\r\n    );\r\n  }, [setGrid]);\r\n\r\n  const generateWeightedMaze = useCallback(() => {\r\n    setGrid((prevGrid) => {\r\n      return prevGrid.map((row) =>\r\n        row.map((node) => {\r\n          // Avoid altering the start, finish, or wall nodes\r\n          if (node.isStart || node.isFinish || node.isWall) return node;\r\n\r\n          // Randomly decide to assign a high weight to some nodes\r\n          const assignHighWeight = Math.random() < 0.2; // 20% chance for simplicity\r\n          if (assignHighWeight) {\r\n            return { ...node, weight: Math.floor(Math.random() * 20) + 20 }; // Weights between 10 and 29\r\n          }\r\n          return node;\r\n        })\r\n      );\r\n    });\r\n  }, [setGrid]);\r\n\r\n  const generateRecursiveDivisionMaze = useCallback(() => {\r\n    setGrid((prevGrid) => {\r\n      // Initialize the grid, preserving the start and finish nodes\r\n      const gridCopy = prevGrid.map((row, rowIndex) =>\r\n        row.map((node, colIndex) => ({\r\n          ...node,\r\n          isWall:\r\n            (rowIndex === 0 ||\r\n              rowIndex === prevGrid.length - 1 ||\r\n              colIndex === 0 ||\r\n              colIndex === row.length - 1) &&\r\n            !node.isStart &&\r\n            !node.isFinish,\r\n        }))\r\n      );\r\n\r\n      divideGrid(\r\n        gridCopy,\r\n        1,\r\n        gridCopy.length - 2,\r\n        1,\r\n        gridCopy[0].length - 2,\r\n        chooseOrientation(gridCopy.length - 2, gridCopy[0].length - 2)\r\n      );\r\n      return gridCopy;\r\n    });\r\n  }, [setGrid]);\r\n\r\n  const chooseOrientation = (height, width) => {\r\n    if (width < height) {\r\n      return \"HORIZONTAL\";\r\n    } else if (height < width) {\r\n      return \"VERTICAL\";\r\n    } else {\r\n      return Math.random() >= 0.5 ? \"HORIZONTAL\" : \"VERTICAL\";\r\n    }\r\n  };\r\n\r\n  const divideGrid = useCallback(\r\n    (grid, rowStart, rowEnd, colStart, colEnd, orientation) => {\r\n      if (rowEnd - rowStart < 2 || colEnd - colStart < 2) {\r\n        return; // Not enough space to divide further\r\n      }\r\n\r\n      const isHorizontal = orientation === \"HORIZONTAL\";\r\n\r\n      if (isHorizontal) {\r\n        const wallRow =\r\n          Math.floor(Math.random() * ((rowEnd - rowStart) / 2)) * 2 +\r\n          rowStart +\r\n          1;\r\n        const passageCol =\r\n          Math.floor(Math.random() * ((colEnd - colStart + 1) / 2)) * 2 +\r\n          colStart;\r\n\r\n        for (let col = colStart; col <= colEnd; col++) {\r\n          if (\r\n            col === passageCol ||\r\n            grid[wallRow][col].isStart ||\r\n            grid[wallRow][col].isFinish\r\n          )\r\n            continue;\r\n          grid[wallRow][col].isWall = true;\r\n        }\r\n\r\n        divideGrid(\r\n          grid,\r\n          rowStart,\r\n          wallRow - 1,\r\n          colStart,\r\n          colEnd,\r\n          chooseOrientation(wallRow - rowStart, colEnd - colStart + 1)\r\n        );\r\n        divideGrid(\r\n          grid,\r\n          wallRow + 1,\r\n          rowEnd,\r\n          colStart,\r\n          colEnd,\r\n          chooseOrientation(rowEnd - wallRow, colEnd - colStart + 1)\r\n        );\r\n      } else {\r\n        const wallCol =\r\n          Math.floor(Math.random() * ((colEnd - colStart) / 2)) * 2 +\r\n          colStart +\r\n          1;\r\n        const passageRow =\r\n          Math.floor(Math.random() * ((rowEnd - rowStart + 1) / 2)) * 2 +\r\n          rowStart;\r\n\r\n        for (let row = rowStart; row <= rowEnd; row++) {\r\n          if (\r\n            row === passageRow ||\r\n            grid[row][wallCol].isStart ||\r\n            grid[row][wallCol].isFinish\r\n          )\r\n            continue;\r\n          grid[row][wallCol].isWall = true;\r\n        }\r\n\r\n        divideGrid(\r\n          grid,\r\n          rowStart,\r\n          rowEnd,\r\n          colStart,\r\n          wallCol - 1,\r\n          chooseOrientation(rowEnd - rowStart + 1, wallCol - colStart)\r\n        );\r\n        divideGrid(\r\n          grid,\r\n          rowStart,\r\n          rowEnd,\r\n          wallCol + 1,\r\n          colEnd,\r\n          chooseOrientation(rowEnd - rowStart + 1, colEnd - wallCol)\r\n        );\r\n      }\r\n    },\r\n    []\r\n  );\r\n\r\n  return {\r\n    randomizeBoard,\r\n    generateWeightedMaze,\r\n    generateRecursiveDivisionMaze,\r\n  };\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}